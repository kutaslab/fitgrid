********
Tutorial
********

The `fitgrid` workflow consists of 3 steps:

0. ``import fitgrid`` and set defaults.
1. Load a ``fitgrid`` epochs table, which creates ``Epochs``.
2. Run a model using the ``Epochs``, which creates a ``FitGrid``.
3. Examine fit or diagnostic information using the ``FitGrid``.

Here are the steps in detail:

========
0. Setup
========

In your preferred Python environment (we recommend Jupyter Notebook or
JupyterLab), run::

    import fitgrid

Now you need to set three library-wide constants that help `fitgrid` properly
ingest your epochs table:

1. ``EPOCH_ID``, the name of the **epoch** identifier column.
2. ``TIME``, the name of the **time** identifier column.
3. ``CHANNELS``, a list of channel columns of interest.

For example::

    fitgrid.EPOCH_ID = 'epoch_id'
    fitgrid.TIME = 'time'
    fitgrid.CHANNELS = ['channel0', 'channel1', 'channel2']


.. note::

    These constants have the following defaults specific to Kutas Lab:

    .. py:module:: fitgrid
    .. autodata:: fitgrid.defaults.CHANNELS
    .. autodata:: fitgrid.defaults.EPOCH_ID
    .. autodata:: fitgrid.defaults.TIME

    In particular, if your epochs table was generated by `mkpy`, you shouldn't
    need to change ``EPOCH_ID`` or ``TIME``.


=================
1. Load in epochs
=================

Epochs tables can come from pandas DataFrames::

    epochs = fitgrid.epochs_from_dataframe(df)

or HDF5 files::

    epochs = fitgrid.epochs_from_hdf('epochs_table.h5')


Input epochs tables are required to have at least two columns in the index:

1. epoch identifier (assumed to be given by ``EPOCH_ID``)
2. time identifier (assumed to be given by ``TIME``)

In addition, it is assumed that each epoch has the same ``TIME`` indices, and
thus for each timepoint we have measurements from the same epochs. Further, for
each timepoint only unique ``EPOCH_ID`` values are allowed.


==============
2. Run a model
==============

As of now, linear regression (via ``statsmodels``' ``ols``) and linear mixed
models (via ``lme4``'s ``lmer``) are available. For example, to run linear
regression on the epochs, use the :code:`lm` function::

    grid = fitgrid.lm(epochs, RHS='continuous + categorical')

:code:`fitgrid.lm` runs linear regression for each channel, with the channel
data as the left hand side, and the right hand side given by the Patsy/R style
formula passed in using the :code:`RHS` parameter.

Similarly, to run `lmer`, use the :code:`lmer` function::

    grid = fitgrid.lmer(epochs, RHS='continuous + (continuous | categorical)')

With lmer especially, it might be useful to run your model with multiple
processes to speed it up. This can be achieved by setting ``parallel`` to
``True`` and ``n_cores`` to the desired value (defaults to 4) as follows::

    grid = fitgrid.lmer(epochs, RHS='continuous + (continuous | categorical)', parallel=True)

or::

    grid = fitgrid.lm(epochs, RHS='continuous + categorical', parallel=True, n_cores=8)

.. note::

    `FitGrid` assumes that the epochs table contains the channels given by
    CHANNELS and throws an error if it doesn't. If you haven't set CHANNELS or
    want to run the model on a specific set of channels, you need pass the
    ``LHS`` parameter::

        grid = fitgrid.lm(
            epochs,
            LHS=['channel0', 'channel1'],
            RHS='continuous + categorical'
        )
        

Running a model on the epochs creates a `FitGrid` object, containing fit
information, such as the betas, and diagnostic information,
such as :math:`R^2` in case of linear regression.

==================
3. Examine results
==================

Now ``grid``, a ``FitGrid`` object, can be queried for attributes just like a
``fit`` object from ``statsmodels`` (see :doc:`/overview` for more
background), for example::

    betas = grid.params
    rsquared_adj = grid.rsquared_adj
    
    influence = grid.get_influence()
    cooks_distance = influence.cooks_distance

If you are using an interactive environment like Jupyter Notebook or IPython,
you can use tab completion to see what attributes are available::

    # type 'grid.' and press Tab
    grid.<TAB>

Calling an attribute of ``grid`` returns either a pandas DataFrame of the
appropriate shape or another ``FitGrid`` object::

    # this is a dataframe
    grid.params

    # this is a FitGrid
    grid.get_influence()

If a dataframe is returned, it is always presented in long form with the same
indices and columns on the outer side as a single epoch: channels as columns
and time as indices.

In addition, slicing on a ``grid`` can be performed to produce a smaller grid
of the shape you want. Suppose you want to only look at a certain channel
within a given timeframe. You can slice as follows::

    smaller_grid = grid[25:75, 'MiPa']

Or multiple channels::

    smaller_grid = grid[25:75, ['MiPa', 'MiPf']]

To include all timepoints or all channels, use a colon::

    # all channels within certain timeframe
    grid[25:75, :]

    # all timepoints, two channels
    grid[:, ['MiPa', 'MiPf']]
