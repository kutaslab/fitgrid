---
title: `fitgrid`: A Python package for multi-channel event-related time series regression modeling
tags:
  - Python
  - EEG electrencephalography
  - MEG magnetoencephalograpy
  - ERP rERP
  - linear regression
  - ordinary least squares
  - linear mixed-effects
  - exploratory data analysis EDA
authors:
  - name: Thomas P. Urbach^[corresponding author: turbach@ucsd.edu]
    orcid: 0000-0001-7993-142X
    affiliation: 1
  - name: Andrey S. Portnoy
    affiliation: 2
affiliations:
 - name: Department of Cognitive Science, University of California, San Diego
   index: 1
 - name: Cerebras Systems
   index: 2
date: 10 Februrary 20201
bibliography: paper.bib
---

# Summary

Electroencephalography (EEG) and magnetetoencephalography (MEG) are
non-invasive human brain imaging modalities with millisecond temporal
resolution. These real-time digital recordings made at or near the
surface of the head measure electrical and magnetic fields generated
by the synchronous activity of populations of neurons as the brain
dynamically processes information. A central challenge for brain
research is that the fields systematically related to events under
experimental control (signals) are generally small relative to much
larger fields generated by concurrent unrelated neuroelectric and
neuromagnetic activity (noise), often differing by one or more orders
of magnitude.

In the early 1950s Dawson demonstrated that time-varying brain
reponses to sensory stimulation too small to see in the wideband EEG
recordings could be detected by aligning several recordings with the
delivery of the stimulus and averaging the values at each point in
time [@Dawson1951; @Dawson1954]. Dawson attributed the suggestion for
applying the approach to EEG to J. N. Hunt and noted several
historical precedents including Laplace's (unsuccessful) 19th century
attempt to isolate small but regular lunar atmospheric tides among the
much larger irregular pressure fluctuations due to other factors
[see @LinCha1969]. As the average accumulates, the large but random
variations (noise) in the individual recordings tends to cancel out
and reveal the time-course of the much smaller response to the
stimulation they have in common (signal). The effects of averaging are
remarkable. Laboratory experiments in subsequent decades found that
sweeping a sum-and-divide averager across multiple EEG recodings could
reveal transient and steady-state brain responses down to fractions of
a microvolt at frequencies up to 100 Hz before, during, and after a
wide range of sensory stimulation, motor responses, and internal
mental events. Oscilloscopic sweep averagers gave way to multichannel
analog-to-digital data acquisition and sum-and-divide averaging in
software on general purpose computers. Since the 1970s, the discrete
time series average event-related brain potential (ERP) has been a
cornerstone of experimental brain research on human sensation,
perception, and cognition [@LucKap2013].

In a seminal paper, Smith and Kutas noted that the average of a set of
values, $y$, is identical to the estimated constant, $\hat{\beta}_{0}$
for the linear model,

$$y = \beta_{0} + e$$

fit by minimizing squared error [@SmiKut2015]. They pointed out that
this makes the sum-and-divide time-domain average ERP mathematically
identical to $\hat\beta_{0}(t)$ and a special case of sweeping a
linear regression model along the EEG. Generalizing this to 
more complex models, e.g., multiple regression, 

$$y(t) = \beta_{0} + \beta_{1}X_{1} \ldots \beta_{p}X_{p} + e$$

likewise produces time series of estimates for the intercept and each
regressor coefficient, the $\hat{\beta}_{0}(t), \hat{\beta}_{1}(t),
\ldots, \hat{\beta}_{p}(t)$ they dubbed regression ERP (rERP)
waveforms. Still more generally, this approach produces a time series
for all the estimated parameters and other basic and derived
quantities of the fitted model such as residual error, coefficient
standard errors, likelihood, Akiake's information criterion, and so
forth.

The insight that sum-and-divide averaging is special case of
regression modeling encourages a shift in perspective from Hunt-Dawson
signal detection to the general framework of applied regression for
fitting, evaluating, and comparing a range of models to account for
systematic variation in the time course of EEG responses. With this
shift, however, comes a new problem.


# Statement of need

Fitting a regression model is relatively straightforward on any
current scientific computing platform. Informative modeling, by
contrast, is a laborious process that iterates cycles of data quality
control, fitting, data diagnosis, model evaluation, comparison,
selection, and interpretation with numerous decision points that
require thought and judgment along the way.

Modeling digitized multichannel EEG data as regression ERPs at each
time point and data channel multiplies the iterative cycles in a
combinatorial explosion of times $\times$ channels $\times$ models
$\times$ comparisons. For example, at a digital sampling rate of 250
samples per second, there are 750 time points in 3 seconds of EEG
data. For 32 EEG channels, this makes 750 timepoints x 32 channels =
24,000 data sets.  To fit three candidate models requires 72,000
separate model fits where the size of the data set might range
anywhere from a few dozens of observations for a single subject to
tens of thousands of observations for a large scale experiment.

Nothing can prevent the combinatorial explosion; `fitgrid` is designed
to contain it.


# fitgrid

![fitgrid TL; DR](../wip/fitgrid_overview.png)

`fitgrid` makes this modeling accessible to any reseacher with a
working knowledge of basic Python scripting and regression modeling
with the symbolic formulae such as $\mathsf{\sim 1 + a + b + a:b}$ and
$\mathsf{\sim 1 + a*b + (a|s) + (a|i) }$ that are currently in wide
use for statistical modeling in Python and R thanks to `patsy` @patsy,
`lm` @Rproject, and `lme4::lmer` @BatesEtAl2015,
[and, before them, `S`, @ChaHas1991; @BecCha1984]. The `fitgrid` user
interface provides access to what are routinely hundreds to tens of
thousands of modeling computations with one line of code (in parallel
if supported by hardware). The fit results across times and channels
are available on demand with the same syntax used to access results in
a single fit object and the results are returned as tidy indexed
`pandas.DataFrames` for further analysis, visualization, and
interpretation. While the origins of `fitgrid` are in EEG data
analysis, `fitgrid` can also be used with other neuroimaging
modalities such as MEG and more generally with synchronized sensor
array time-series data from other domains where event-related
regression modeling is appropriate.  `fitgrid` enables researchers to
conduct this type of computationally intensive modeling flexibly,
efficiently, informatively, and reproducibly with familiar scientific
computing tools and minimal programming. These features make `fitgrid`
particularly well-suited for systematic exploratory data analysis
(EDA) as in @UrbDelChaKut2020 and @TroUrbKut2020.


# Documentation

![fitgrid documentation on [https://kutaslab/github.io/fitgrid](https::/kutaslab/github.io/fitgrid)](fitgrid_docs.png)

The `fitgrid` documentation is available online:
https://kutaslab.github.io/fitgrid-dev.

* [Getting Started]() outlines and illustrates the `fitgrid` analysis workflow with
   downloadable and executable examples.
   
* The [User Guide]() provides additional information about specific
  topics including how the OLS models are fit in Python `statsmodels`
  [@SeaPer2010] and the LMER models are fit in R [`lme4::lmer`,
  `lmerTest` @KuzBroChr2017] via `pymer4` [@Jolly2018].

* The [API Reference]() is a complete listing of `fitgrid` classes,
  methods, attributes, and functions auto-generated with numpy-style
  docstrings and links to the source code.

* The [Bibliography]() includes references to relevant experimental
  and technical literature.


## Examples

The [Examples Gallery]() in the online documentation contains
`fitgrid` vignettes with simulated data, experimental EEG recordings,
and NOAA tide and atmospheric observations. The Examples Gallery can
be downloaded as executable Python scripts or Jupyter notebooks thanks
to [sphinx-gallery](https://sphinx-gallery.github.io/).

![Downloadable Examples Gallery](examples_gallery.png)

## Installation, Source, Continuous Integration, and Testing

The online documentation includes [installation instructions]() and
system recommendations.  The latest stable release of `fitgrid` and
the bleeding edge pre-release development version are packaged for
x86_64 linux and distributed on Anaconda Cloud. The recommended
installation into a fresh conda virtual environment is a one-line
shell command like so:

```bash
    $ conda create --name fg_env -c kutaslab -c defaults -c conda-forge fitgrid
```

As a courtesy, 64-bit Intel OSX and Windows packages are distributed
on Anaconda and the Python sdist is uploaded to PyPI. These are not
tested, contributed field reports are welcome.

The source code is hosted in a public github repository
[https://github.com/kutaslab/fitgrid-dev)](https://github.com/kutaslab/fitgrid-dev)
and Issues may be posted there in accordance with the `fitgrid` Code
of Conduct.

`fitgrid` is developed and tested locally on a high-performance
48-core CentOS 7 server. Continuous integration on the main code
branch runs nightly with Github Actions. The action runs conda build,
conda install, and pytest on the latest stable release of the
`fitgrid` x86_64 linux package on Ubuntu 18.04. Pre-release packages
pass CI before deployment to Anaconda Cloud.


## How it works

Ordinary least squares models are fit in Python using the
`statsmodels`_ statstics package and the `patsy
<https://patsy.readthedocs.io/en/latest/>`_ formula language. Linear
mixed effects models are shipped out of Python and into R via Eshin
Jolly's `pymer4 <https://github.com/kmerkmer/pymer>`_ interface
[Jolly2018]_, and fit with `lme4::lmer
<https://cran.r-project.org/web/packages/lme4/index.html>`_ (see
[BatesEtAl2015]_).

For illustration with `patsy` and `statsmodels`, suppose you have a
pandas DataFrame ``data`` with independent variables ``x`` and ``a``,
where ``x`` is continuous and ``a`` is categorical. Suppose also
``channel`` is your continuous dependent variable.  Here's how you
would run an ordinary least squares linear regression of ``y`` on
``x + a`` using `statsmodels <http://www.statsmodels.org>`_::

    from statsmodels.formula.api import ols

    fit = ols('channel ~ x + a', data).fit()

Now this ``fit`` object contains all the fit and diagnostic information,
mirroring what is provided by ``lm`` in R. This information can be retrieved by
accessing various attributes of ``fit``. For example, the betas::

    betas = fit.params

or the t-values::
    
    tvalues = fit.tvalues

or $Pr(>|t|)`::

    pvalues = fit.pvalues

Compare to R, where this is usually done by calling functions like ``summary``
or ``coef``. 

Now the issue with using that interface for single trial rERP analyses
is of course the dimensionality: instead of fitting a single model, we
need to fit $m \times n$ models, where $m$ is the number
of discrete time points and $n` is the number of channels.

This can be handled using ``for`` loops of the form::

    for channel in channels:
        for timepoint in timepoints:
            # run regression 'channel ~ x + a', save fit object somewhere

And to access some particular kind of fit information, the exact same two
nested ``for`` loops are required::

    for channel in channels:
        for timepoint in timepoints:
            # extract diagnostic or fit measure, save it somewhere


``fitgrid`` abstracts this complexity away and handles the iteration and
storage of the data behind the scenes. The first loop above is now replaced
with

    lm_grid = fitgrid.lm(epochs, RHS='x + a')

and the second loop with

    betas = lm_grid.params

or

    tvalues = lm_grid.tvalues

or

    pvalues = lm_grid.pvalues

The crux of the approach is that ``lm_grid``, a ``FitGrid`` object,
can be queried for the exact same attributes as a regular
``statsmodels`` ``fit`` object as above.

The result is most often a pandas DataFrame, sometimes another
``FitGrid``. In other words, if you are running linear regression, any
attribute of a fit object ` by ``statsmodels`` as part of their API
[statsmodels.OLS.RegressionResults](http://www.statsmodels.org/stable/generated/statsmodels.regression.linear_model.RegressionResults.html), can be used to query a
``FitGrid``.

``statsmodels``

>	fit.rsquared

``fitgrid``

>    lm_grid.rsquared

Some of the attributes are methods. For example, influence diagnostics in
``statsmodels`` are stored in a separate object that is created by calling the
``get_influence`` method. So Cook's distance measures can be retrieved as follows::

    influence = fit.get_influence()
    cooks_d = influence.cooks_distance

The exact same approach works in ``fitgrid``

    influence = lm_grid.get_influence()
    cooks_d = influence.cooks_distance




# Acknowledgements

We gratefully acknowledge contributions to prototypes by Lauren Liao
and testing and feedback during development by Anna Melissa Troyer,
Anna Stoermann, and Emily Provenzano. This work was supported by grant
NICHD 5R01HD022614 to Marta Kutas.

# References
